From 55a2913e4a2ffb265ceb1abd0471bff4895f3124 Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <heinrich.schuchardt@canonical.com>
Date: Tue, 18 Jan 2022 11:55:56 +0100
Subject: [PATCH 1/1] Add read_header_pe() function

Signed-off-by: Heinrich Schuchardt <heinrich.schuchardt@canonical.com>
---
 grub-core/loader/efi/chainloader.c | 591 ++++++++++++++++++++--
 include/grub/peimage.h             | 759 +++++++++++++++++++++++++++++
 2 files changed, 1299 insertions(+), 51 deletions(-)
 create mode 100644 include/grub/peimage.h

diff --git a/grub-core/loader/efi/chainloader.c b/grub-core/loader/efi/chainloader.c
index 4a85f4116..c23669af5 100644
--- a/grub-core/loader/efi/chainloader.c
+++ b/grub-core/loader/efi/chainloader.c
@@ -39,6 +39,7 @@
 #include <grub/command.h>
 #include <grub/i18n.h>
 #include <grub/net.h>
+#include <grub/peimage.h>
 #if defined (__i386__) || defined (__x86_64__)
 #include <grub/macho.h>
 #include <grub/i386/macho.h>
@@ -46,6 +47,8 @@
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
+#define PAGE_SIZE 4096
+
 static grub_dl_t my_mod;
 
 static grub_efi_physical_address_t address;
@@ -59,6 +62,76 @@ static grub_efi_handle_t dev_handle;
 
 static grub_efi_status_t (*entry_point) (grub_efi_handle_t image_handle, grub_efi_system_table_t *system_table);
 
+static const grub_uint16_t machine_type __attribute__((__unused__)) =
+#if defined(__x86_64__)
+  GRUB_PE32_MACHINE_X86_64;
+#elif defined(__aarch64__)
+  GRUB_PE32_MACHINE_ARM64;
+#elif defined(__arm__)
+  GRUB_PE32_MACHINE_ARMTHUMB_MIXED;
+#elif defined(__i386__) || defined(__i486__) || defined(__i686__)
+  GRUB_PE32_MACHINE_I386;
+#elif defined(__ia64__)
+  GRUB_PE32_MACHINE_IA64;
+#elif defined(__riscv) && __riscv_xlen == 64
+  GRUB_PE32_MACHINE_RISCV64;
+#else
+#error this architecture is not supported by grub2
+#endif
+
+#define SHIM_LOCK_GUID \
+  { 0x605dab50, 0xe046, 0x4300, { 0xab,0xb6,0x3d,0xd8,0x10,0xdd,0x8b,0x23 } }
+
+typedef union
+{
+  struct grub_pe32_header_32 pe32;
+  struct grub_pe32_header_64 pe32plus;
+} grub_pe_header_t;
+
+struct pe_coff_loader_image_context
+{
+  grub_efi_uint64_t image_address;
+  grub_efi_uint64_t image_size;
+  grub_efi_uint64_t entry_point;
+  grub_efi_uintn_t size_of_headers;
+  grub_efi_uint16_t image_type;
+  grub_efi_uint16_t number_of_sections;
+  grub_efi_uint32_t section_alignment;
+  struct grub_pe32_section_table *first_section;
+  struct grub_pe32_data_directory *reloc_dir;
+  struct grub_pe32_data_directory *sec_dir;
+  grub_efi_uint64_t number_of_rva_and_sizes;
+  grub_pe_header_t *pe_hdr;
+};
+
+typedef struct pe_coff_loader_image_context pe_coff_loader_image_context_t;
+
+struct grub_efi_shim_lock
+{
+  grub_efi_status_t (*verify)(void *buffer,
+                              grub_efi_uint32_t size);
+  grub_efi_status_t (*hash)(void *data,
+                            grub_efi_int32_t datasize,
+                            pe_coff_loader_image_context_t *context,
+                            grub_efi_uint8_t *sha256hash,
+                            grub_efi_uint8_t *sha1hash);
+  grub_efi_status_t (*context)(void *data,
+                               grub_efi_uint32_t size,
+                               pe_coff_loader_image_context_t *context);
+};
+
+typedef struct grub_efi_shim_lock grub_efi_shim_lock_t;
+
+static int
+image_is_64_bit(grub_pe_header_t *pe_hdr)
+{
+	/* .Magic is the same offset in all cases */
+	if (pe_hdr->pe32plus.optional_header.magic
+			== EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+		return 1;
+	return 0;
+}
+
 static grub_err_t
 grub_chainloader_unload (void)
 {
@@ -223,48 +296,480 @@ make_file_path (grub_efi_device_path_t *dp, const char *filename)
   return file_path;
 }
 
-#define SHIM_LOCK_GUID \
-  { 0x605dab50, 0xe046, 0x4300, { 0xab,0xb6,0x3d,0xd8,0x10,0xdd,0x8b,0x23 } }
+static int
+allow_64_bit(void)
+{
+#if defined(__x86_64__) || defined(__aarch64__) || (defined(__riscv) && __riscv_xlen == 64)
+	return 1;
+#else /* assuming everything else is 32-bit... */
+	return 0;
+#endif
+}
 
-typedef union
+static int
+allow_32_bit(void)
 {
-  struct grub_pe32_header_32 pe32;
-  struct grub_pe32_header_64 pe32plus;
-} grub_pe_header_t;
+#if defined(__x86_64__) || defined(__aarch64__) || (defined(__riscv) && __riscv_xlen == 64)
+	return 0;
+#else /* assuming everything else is 32-bit... */
+	return 1;
+#endif
+}
 
-struct pe_coff_loader_image_context
+static int
+image_is_loadable(grub_pe_header_t *pe_hdr)
 {
-  grub_efi_uint64_t image_address;
-  grub_efi_uint64_t image_size;
-  grub_efi_uint64_t entry_point;
-  grub_efi_uintn_t size_of_headers;
-  grub_efi_uint16_t image_type;
-  grub_efi_uint16_t number_of_sections;
-  grub_efi_uint32_t section_alignment;
-  struct grub_pe32_section_table *first_section;
-  struct grub_pe32_data_directory *reloc_dir;
-  struct grub_pe32_data_directory *sec_dir;
-  grub_efi_uint64_t number_of_rva_and_sizes;
-  grub_pe_header_t *pe_hdr;
-};
+	/* If the machine type doesn't match the binary, bail, unless
+	 * we're in an allowed 64-on-32 scenario */
+	if (pe_hdr->pe32.coff_header.machine != machine_type) {
+		if (!(machine_type == IMAGE_FILE_MACHINE_I386 &&
+		      pe_hdr->pe32.coff_header.machine == IMAGE_FILE_MACHINE_X64 &&
+		      allow_64_bit())) {
+			return 0;
+		}
+	}
 
-typedef struct pe_coff_loader_image_context pe_coff_loader_image_context_t;
+	/* If it's not a header type we recognize at all, bail */
+	switch (pe_hdr->pe32plus.optional_header.magic) {
+	case EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC:
+	case EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC:
+		break;
+	default:
+		return 0;
+	}
 
-struct grub_efi_shim_lock
+	/* and now just check for general 64-vs-32 compatibility */
+	if (image_is_64_bit(pe_hdr)) {
+		if (allow_64_bit())
+			return 1;
+	} else {
+		if (allow_32_bit())
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Read the binary header and grab appropriate information from it
+ */
+static grub_efi_status_t
+read_header_read(void *data, unsigned int datasize,
+	    pe_coff_loader_image_context_t *context)
 {
-  grub_efi_status_t (*verify)(void *buffer,
-                              grub_efi_uint32_t size);
-  grub_efi_status_t (*hash)(void *data,
-                            grub_efi_int32_t datasize,
-                            pe_coff_loader_image_context_t *context,
-                            grub_efi_uint8_t *sha256hash,
-                            grub_efi_uint8_t *sha1hash);
-  grub_efi_status_t (*context)(void *data,
-                               grub_efi_uint32_t size,
-                               pe_coff_loader_image_context_t *context);
-};
+	EFI_IMAGE_DOS_HEADER *dos_hdr = data;
+	grub_pe_header_t *pe_hdr = data;
+	unsigned long HeaderWithoutDataDir, SectionHeaderOffset, OptHeaderSize;
+	unsigned long FileAlignment = 0;
+
+	if (datasize < sizeof (pe_hdr->pe32)) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Invalid image"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
 
-typedef struct grub_efi_shim_lock grub_efi_shim_lock_t;
+	if (dos_hdr->e_magic != EFI_IMAGE_DOS_SIGNATURE) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Invalid image"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+	pe_hdr = (void *)((unsigned long)data + dos_hdr->e_lfanew);
+
+	if (!image_is_loadable(pe_hdr)) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("Platform does not support this image"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if (image_is_64_bit(pe_hdr)) {
+		context->number_of_rva_and_sizes = pe_hdr->pe32plus.optional_header.num_data_directories;
+		context->size_of_headers = pe_hdr->pe32plus.optional_header.header_size;
+		context->image_size = pe_hdr->pe32plus.optional_header.image_size;
+		context->section_alignment = pe_hdr->pe32plus.optional_header.section_alignment;
+		FileAlignment = pe_hdr->pe32plus.optional_header.file_alignment;
+		OptHeaderSize = sizeof(EFI_IMAGE_OPTIONAL_HEADER64);
+	} else {
+		context->number_of_rva_and_sizes = pe_hdr->pe32.optional_header.num_data_directories;
+		context->size_of_headers = pe_hdr->pe32.optional_header.header_size;
+		context->image_size = (grub_uint64_t)pe_hdr->pe32.optional_header.image_size;
+		context->section_alignment = pe_hdr->pe32.optional_header.section_alignment;
+		FileAlignment = pe_hdr->pe32.optional_header.file_alignment;
+		OptHeaderSize = sizeof(EFI_IMAGE_OPTIONAL_HEADER32);
+	}
+
+	if (FileAlignment % 2 != 0) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("File Alignment is invalid (%ld)"),
+			    FileAlignment);
+		return GRUB_EFI_UNSUPPORTED;
+	}
+	if (FileAlignment == 0)
+		FileAlignment = 0x200;
+	if (context->section_alignment == 0)
+		context->section_alignment = PAGE_SIZE;
+	if (context->section_alignment < FileAlignment)
+		context->section_alignment = FileAlignment;
+
+	context->number_of_sections = pe_hdr->pe32.coff_header.num_sections;
+
+	if (EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES < context->number_of_rva_and_sizes) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Image header too small"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	HeaderWithoutDataDir = OptHeaderSize
+			- sizeof (EFI_IMAGE_DATA_DIRECTORY) * EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES;
+	if (((grub_efi_uint32_t)pe_hdr->pe32.coff_header.optional_header_size - HeaderWithoutDataDir) !=
+			context->number_of_rva_and_sizes * sizeof (EFI_IMAGE_DATA_DIRECTORY)) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("Image header overflows data directory"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	SectionHeaderOffset = dos_hdr->e_lfanew
+				+ sizeof (grub_efi_uint32_t)
+				+ sizeof (EFI_IMAGE_FILE_HEADER)
+				+ pe_hdr->pe32.coff_header.optional_header_size;
+	if (((grub_efi_uint32_t)context->image_size - SectionHeaderOffset) / EFI_IMAGE_SIZEOF_SECTION_HEADER
+			<= context->number_of_sections) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("Image sections overflow image size"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if ((context->size_of_headers - SectionHeaderOffset) / EFI_IMAGE_SIZEOF_SECTION_HEADER
+			< (grub_efi_uint32_t)context->number_of_sections) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("Image sections overflow section headers"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if ((((grub_efi_uint8_t *)pe_hdr - (grub_efi_uint8_t *)data) + sizeof(EFI_IMAGE_OPTIONAL_HEADER_UNION)) > datasize) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Invalid image"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if (pe_hdr->pe32.coff_header.characteristics & EFI_IMAGE_FILE_RELOCS_STRIPPED) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("Unsupported image - Relocations have been stripped"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	context->pe_hdr = pe_hdr;
+
+	if (image_is_64_bit(pe_hdr)) {
+		context->image_address = pe_hdr->pe32plus.optional_header.image_base;
+		context->entry_point = pe_hdr->pe32plus.optional_header.entry_addr;
+		context->reloc_dir = &pe_hdr->pe32plus.optional_header.base_relocation_table;
+		context->sec_dir = &pe_hdr->pe32plus.optional_header.certificate_table;
+	} else {
+		context->image_address = pe_hdr->pe32.optional_header.image_base;
+		context->entry_point = pe_hdr->pe32.optional_header.entry_addr;
+		context->reloc_dir = &pe_hdr->pe32.optional_header.base_relocation_table;
+		context->sec_dir = &pe_hdr->pe32.optional_header.certificate_table;
+	}
+
+	context->first_section = (void *)((unsigned long)pe_hdr +
+				 pe_hdr->pe32.coff_header.optional_header_size +
+				 sizeof(grub_efi_uint32_t) +
+				 sizeof(struct grub_pe32_coff_header));
+
+	if (context->image_size < context->size_of_headers) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Invalid image"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if ((unsigned long)((grub_efi_uint8_t *)context->sec_dir - (grub_efi_uint8_t *)data) >
+	    (datasize - sizeof(EFI_IMAGE_DATA_DIRECTORY))) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Invalid image"));
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if (context->sec_dir->rva > datasize ||
+	    (context->sec_dir->rva == datasize &&
+	     context->sec_dir->size > 0)) {
+		grub_error (GRUB_ERR_BAD_OS, N_("Malformed security header"));
+		return GRUB_EFI_INVALID_PARAMETER;
+	}
+	return GRUB_EFI_SUCCESS;
+}
+
+/*
+ * Once the image has been loaded it needs to be validated and relocated
+ */
+grub_efi_status_t
+handle_image (void *data, unsigned int datasize,
+	      grub_efi_loaded_image_t *li,
+	      EFI_IMAGE_ENTRY_POINT *entry_point,
+	      grub_efi_physical_address_t *alloc_address,
+	      grub_efi_uintn_t *alloc_pages)
+{
+	EFI_STATUS efi_status;
+	char *buffer;
+	int i;
+	EFI_IMAGE_SECTION_HEADER *Section;
+	char *base, *end;
+	pe_coff_loader_image_context_t context;
+	unsigned int alignment, alloc_size;
+	int found_entry_point = 0;
+	grub_efi_uint8_t sha1hash[SHA1_DIGEST_SIZE];
+	grub_efi_uint8_t sha256hash[SHA256_DIGEST_SIZE];
+
+	/*
+	 * The binary header contains relevant context and section pointers
+	 */
+	efi_status = read_header(data, datasize, &context);
+	if (EFI_ERROR(efi_status)) {
+		grub_error (GRUB_ERR_BAD_OS, "Failed to read header: %u",
+			    (unsigned int)efi_status);
+		return efi_status;
+	}
+
+	/*
+	 * We only need to verify the binary if we're in secure mode
+	 */
+	efi_status = generate_hash(data, datasize, &context, sha256hash,
+				   sha1hash);
+	if (EFI_ERROR(efi_status))
+		return efi_status;
+
+	/* Measure the binary into the TPM */
+#ifdef REQUIRE_TPM
+	efi_status =
+#endif
+	tpm_log_pe((EFI_PHYSICAL_ADDRESS)(UINTN)data, datasize,
+		   (EFI_PHYSICAL_ADDRESS)(UINTN)context.ImageAddress,
+		   li->FilePath, sha1hash, 4);
+#ifdef REQUIRE_TPM
+	if (efi_status != EFI_SUCCESS) {
+		return efi_status;
+	}
+#endif
+
+	/* The spec says, uselessly, of SectionAlignment:
+	 * =====
+	 * The alignment (in bytes) of sections when they are loaded into
+	 * memory. It must be greater than or equal to FileAlignment. The
+	 * default is the page size for the architecture.
+	 * =====
+	 * Which doesn't tell you whose responsibility it is to enforce the
+	 * "default", or when.  It implies that the value in the field must
+	 * be > FileAlignment (also poorly defined), but it appears visual
+	 * studio will happily write 512 for FileAlignment (its default) and
+	 * 0 for SectionAlignment, intending to imply PAGE_SIZE.
+	 *
+	 * We only support one page size, so if it's zero, nerf it to 4096.
+	 */
+	alignment = context.SectionAlignment;
+	if (!alignment)
+		alignment = PAGE_SIZE;
+
+	alloc_size = ALIGN_VALUE(context.ImageSize + context.SectionAlignment,
+				 PAGE_SIZE);
+	*alloc_pages = alloc_size / PAGE_SIZE;
+
+	efi_status = BS->AllocatePages(AllocateAnyPages, EfiLoaderCode,
+				       *alloc_pages, alloc_address);
+	if (EFI_ERROR(efi_status)) {
+		grub_error (GRUB_ERR_BAD_OS, "Failed to allocate image buffer");
+		return GRUB_EFI_OUT_OF_RESOURCES;
+	}
+
+	buffer = (void *)ALIGN_VALUE((unsigned long)*alloc_address, alignment);
+
+	CopyMem(buffer, data, context.SizeOfHeaders);
+
+	*entry_point = ImageAddress(buffer, context.ImageSize, context.EntryPoint);
+	if (!*entry_point) {
+		grub_error (GRUB_ERR_BAD_OS, "Entry point is invalid");
+		BS->FreePages(*alloc_address, *alloc_pages);
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	char *RelocBase, *RelocBaseEnd;
+	/*
+	 * These are relative virtual addresses, so we have to check them
+	 * against the image size, not the data size.
+	 */
+	RelocBase = ImageAddress(buffer, context.ImageSize,
+				 context.RelocDir->VirtualAddress);
+	/*
+	 * RelocBaseEnd here is the address of the last byte of the table
+	 */
+	RelocBaseEnd = ImageAddress(buffer, context.ImageSize,
+				    context.RelocDir->VirtualAddress +
+				    context.RelocDir->Size - 1);
+
+	EFI_IMAGE_SECTION_HEADER *RelocSection = NULL;
+
+	char *SBATBase = NULL;
+	size_t SBATSize = 0;
+
+	/*
+	 * Copy the executable's sections to their desired offsets
+	 */
+	Section = context.FirstSection;
+	for (i = 0; i < context.NumberOfSections; i++, Section++) {
+		/* Don't try to copy discardable sections with zero size */
+		if ((Section->Characteristics & EFI_IMAGE_SCN_MEM_DISCARDABLE) &&
+		    !Section->Misc.VirtualSize)
+			continue;
+
+		base = ImageAddress (buffer, context.ImageSize,
+				     Section->VirtualAddress);
+		end = ImageAddress (buffer, context.ImageSize,
+				    Section->VirtualAddress
+				     + Section->Misc.VirtualSize - 1);
+
+		if (end < base) {
+			grub_error (GRUB_ERR_BAD_OS,
+				    "Section %d has negative size", i);
+			BS->FreePages(*alloc_address, *alloc_pages);
+			return GRUB_EFI_UNSUPPORTED;
+		}
+
+		if (Section->VirtualAddress <= context.EntryPoint &&
+		    (Section->VirtualAddress + Section->SizeOfRawData - 1)
+		    > context.EntryPoint)
+			found_entry_point++;
+
+		/* We do want to process .reloc, but it's often marked
+		 * discardable, so we don't want to memcpy it. */
+		if (CompareMem(Section->Name, ".reloc\0\0", 8) == 0) {
+			if (RelocSection) {
+				grub_error (GRUB_ERR_BAD_OS,
+					    "Image has multiple relocation sections");
+				return GRUB_EFI_UNSUPPORTED;
+			}
+			/* If it has nonzero sizes, and our bounds check
+			 * made sense, and the VA and size match RelocDir's
+			 * versions, then we believe in this section table. */
+			if (Section->SizeOfRawData &&
+					Section->Misc.VirtualSize &&
+					base && end &&
+					RelocBase == base &&
+					RelocBaseEnd == end) {
+				RelocSection = Section;
+			}
+		} else if (CompareMem(Section->Name, ".sbat\0\0\0", 8) == 0) {
+			if (SBATBase || SBATSize) {
+				grub_error (GRUB_ERR_BAD_OS,
+					    "Image has multiple SBAT sections");
+				return GRUB_EFI_UNSUPPORTED;
+			}
+
+			if (Section->NumberOfRelocations != 0 ||
+			    Section->PointerToRelocations != 0) {
+				grub_error (GRUB_ERR_BAD_OS,
+					    "SBAT section has relocations");
+				return GRUB_EFI_UNSUPPORTED;
+			}
+
+			/* The virtual size corresponds to the size of the SBAT
+			 * metadata and isn't necessarily a multiple of the file
+			 * alignment. The on-disk size is a multiple of the file
+			 * alignment and is zero padded. Make sure that the
+			 * on-disk size is at least as large as virtual size,
+			 * and ignore the section if it isn't. */
+			if (Section->SizeOfRawData &&
+			    Section->SizeOfRawData >= Section->Misc.VirtualSize &&
+			    base && end) {
+				SBATBase = base;
+				/* +1 because of size vs last byte location */
+				SBATSize = end - base + 1;
+				dprint(L"sbat section base:0x%lx size:0x%lx\n",
+				       SBATBase, SBATSize);
+			}
+		}
+
+		if (Section->Characteristics & EFI_IMAGE_SCN_MEM_DISCARDABLE) {
+			continue;
+		}
+
+		if (!base) {
+			grub_error (GRUB_ERR_BAD_OS,
+				    "Section %d has invalid base address", i);
+			return GRUB_EFI_UNSUPPORTED;
+		}
+		if (!end) {
+			grub_error (GRUB_ERR_BAD_OS, "Section %d has zero size",
+				    i);
+			return GRUB_EFI_UNSUPPORTED;
+		}
+
+		if (!(Section->Characteristics & EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA) &&
+		    (Section->VirtualAddress < context.SizeOfHeaders ||
+		     Section->PointerToRawData < context.SizeOfHeaders)) {
+			grub_error (GRUB_ERR_BAD_OS,
+				    "Section %d is inside image headers", i);
+			return GRUB_EFI_UNSUPPORTED;
+		}
+
+		if (Section->Characteristics & EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
+			ZeroMem(base, Section->Misc.VirtualSize);
+		} else {
+			if (Section->PointerToRawData < context.SizeOfHeaders) {
+				grub_error (GRUB_ERR_BAD_OS,
+					    "Section %d is inside image headers",
+					    i);
+				return GRUB_EFI_UNSUPPORTED;
+			}
+
+			if (Section->SizeOfRawData > 0)
+				CopyMem(base, data + Section->PointerToRawData,
+					Section->SizeOfRawData);
+
+			if (Section->SizeOfRawData < Section->Misc.VirtualSize)
+				ZeroMem(base + Section->SizeOfRawData,
+					Section->Misc.VirtualSize - Section->SizeOfRawData);
+		}
+	}
+
+	if (context.NumberOfRvaAndSizes <= EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC) {
+		grub_error (GRUB_ERR_BAD_OS, "Image has no relocation entry");
+		FreePool(buffer);
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	if (context.RelocDir->Size && RelocSection) {
+		/*
+		 * Run the relocation fixups
+		 */
+		efi_status = relocate_coff(&context, RelocSection, data,
+					   buffer);
+
+		if (EFI_ERROR(efi_status)) {
+			perror(L"Relocation failed: %r\n", efi_status);
+			grub_error (GRUB_ERR_BAD_OS,
+				    "Relocation failed: %u",
+				    (unsigned int)efi_status);
+			FreePool(buffer);
+			return efi_status;
+		}
+	}
+
+	/*
+	 * grub needs to know its location and size in memory, so fix up
+	 * the loaded image protocol values
+	 */
+	li->image_base = buffer;
+	li->ImageSize = context.ImageSize;
+
+	/* Pass the load options to the second stage loader */
+	li->LoadOptions = load_options;
+	li->LoadOptionsSize = load_options_size;
+
+	if (!found_entry_point) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    "Entry point is not within sections")
+		return GRUB_EFI_UNSUPPORTED;
+	}
+	if (found_entry_point > 1) {
+		grub_error (GRUB_ERR_BAD_OS,
+			    N_("%d sections contain entry point"),
+			    found_entry_point);
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	return GRUB_EFI_SUCCESS;
+}
 
 static grub_efi_boolean_t
 read_header (void *data, grub_efi_uint32_t size,
@@ -278,6 +783,7 @@ read_header (void *data, grub_efi_uint32_t size,
   if (!shim_lock)
     {
       grub_dprintf ("chain", "no shim lock protocol");
+      read_header_shim (data, size, context);
       return 0;
     }
 
@@ -323,23 +829,6 @@ image_is_64_bit (grub_pe_header_t *pe_hdr)
   return 0;
 }
 
-static const grub_uint16_t machine_type __attribute__((__unused__)) =
-#if defined(__x86_64__)
-  GRUB_PE32_MACHINE_X86_64;
-#elif defined(__aarch64__)
-  GRUB_PE32_MACHINE_ARM64;
-#elif defined(__arm__)
-  GRUB_PE32_MACHINE_ARMTHUMB_MIXED;
-#elif defined(__i386__) || defined(__i486__) || defined(__i686__)
-  GRUB_PE32_MACHINE_I386;
-#elif defined(__ia64__)
-  GRUB_PE32_MACHINE_IA64;
-#elif defined(__riscv) && __riscv_xlen == 64
-  GRUB_PE32_MACHINE_RISCV64;
-#else
-#error this architecture is not supported by grub2
-#endif
-
 static grub_efi_status_t
 relocate_coff (pe_coff_loader_image_context_t *context,
 	       struct grub_pe32_section_table *section,
diff --git a/include/grub/peimage.h b/include/grub/peimage.h
new file mode 100644
index 000000000..d3f9c4fbb
--- /dev/null
+++ b/include/grub/peimage.h
@@ -0,0 +1,759 @@
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+/*
+ * EFI image format for PE32, PE32+ and TE. Please note some data structures
+ * are different for PE32 and PE32+. EFI_IMAGE_NT_HEADERS32 is for PE32 and
+ * EFI_IMAGE_NT_HEADERS64 is for PE32+.
+ *
+ * This file is coded to the Visual Studio, Microsoft Portable Executable and
+ * Common Object File Format Specification, Revision 8.0 - May 16, 2006. This
+ * file also includes some definitions in PI Specification, Revision 1.0.
+ *
+ * Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.
+ * Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.
+ */
+
+#ifndef SHIM_PEIMAGE_H
+#define SHIM_PEIMAGE_H
+
+#include <grub/efi/api.h>
+
+#define SIGNATURE_16(A, B)        ((A) | (B << 8))
+#define SIGNATURE_32(A, B, C, D)  (SIGNATURE_16 (A, B) | (SIGNATURE_16 (C, D) << 16))
+#define SIGNATURE_64(A, B, C, D, E, F, G, H) \
+	(SIGNATURE_32 (A, B, C, D) | ((grub_uint64_t) (SIGNATURE_32 (E, F, G, H)) << 32))
+
+#define ALIGN_VALUE(Value, Alignment) ((Value) + (((Alignment) - (Value)) & ((Alignment) - 1)))
+#define ALIGN_POINTER(Pointer, Alignment) ((VOID *) (ALIGN_VALUE ((grub_uintn_t)(Pointer), (Alignment))))
+
+//
+// PE32+ Subsystem type for EFI images
+//
+#define EFI_IMAGE_SUBSYSTEM_EFI_APPLICATION         10
+#define EFI_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11
+#define EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER      12
+#define EFI_IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER      13 ///< defined PI Specification, 1.0
+
+
+//
+// PE32+ Machine type for EFI images
+//
+#define IMAGE_FILE_MACHINE_I386            0x014c
+#define IMAGE_FILE_MACHINE_IA64            0x0200
+#define IMAGE_FILE_MACHINE_EBC             0x0EBC
+#define IMAGE_FILE_MACHINE_X64             0x8664
+#define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED  0x01c2
+#define IMAGE_FILE_MACHINE_ARM64	   0xaa64
+
+//
+// EXE file formats
+//
+#define EFI_IMAGE_DOS_SIGNATURE     SIGNATURE_16('M', 'Z')
+#define EFI_IMAGE_OS2_SIGNATURE     SIGNATURE_16('N', 'E')
+#define EFI_IMAGE_OS2_SIGNATURE_LE  SIGNATURE_16('L', 'E')
+#define EFI_IMAGE_NT_SIGNATURE      SIGNATURE_32('P', 'E', '\0', '\0')
+
+///
+/// PE images can start with an optional DOS header, so if an image is run
+/// under DOS it can print an error message.
+///
+typedef struct {
+  grub_uint16_t  e_magic;    ///< Magic number.
+  grub_uint16_t  e_cblp;     ///< Bytes on last page of file.
+  grub_uint16_t  e_cp;       ///< Pages in file.
+  grub_uint16_t  e_crlc;     ///< Relocations.
+  grub_uint16_t  e_cparhdr;  ///< Size of header in paragraphs.
+  grub_uint16_t  e_minalloc; ///< Minimum extra paragraphs needed.
+  grub_uint16_t  e_maxalloc; ///< Maximum extra paragraphs needed.
+  grub_uint16_t  e_ss;       ///< Initial (relative) SS value.
+  grub_uint16_t  e_sp;       ///< Initial SP value.
+  grub_uint16_t  e_csum;     ///< Checksum.
+  grub_uint16_t  e_ip;       ///< Initial IP value.
+  grub_uint16_t  e_cs;       ///< Initial (relative) CS value.
+  grub_uint16_t  e_lfarlc;   ///< File address of relocation table.
+  grub_uint16_t  e_ovno;     ///< Overlay number.
+  grub_uint16_t  e_res[4];   ///< Reserved words.
+  grub_uint16_t  e_oemid;    ///< OEM identifier (for e_oeminfo).
+  grub_uint16_t  e_oeminfo;  ///< OEM information; e_oemid specific.
+  grub_uint16_t  e_res2[10]; ///< Reserved words.
+  grub_uint32_t  e_lfanew;   ///< File address of new exe header.
+} EFI_IMAGE_DOS_HEADER;
+
+///
+/// COFF File Header (Object and Image).
+///
+typedef struct {
+  grub_uint16_t  Machine;
+  grub_uint16_t  NumberOfSections;
+  grub_uint32_t  TimeDateStamp;
+  grub_uint32_t  PointerToSymbolTable;
+  grub_uint32_t  NumberOfSymbols;
+  grub_uint16_t  SizeOfOptionalHeader;
+  grub_uint16_t  Characteristics;
+} EFI_IMAGE_FILE_HEADER;
+
+///
+/// Size of EFI_IMAGE_FILE_HEADER.
+///
+#define EFI_IMAGE_SIZEOF_FILE_HEADER        20
+
+//
+// Characteristics
+//
+#define EFI_IMAGE_FILE_RELOCS_STRIPPED      (1 << 0)     ///< 0x0001  Relocation info stripped from file.
+#define EFI_IMAGE_FILE_EXECUTABLE_IMAGE     (1 << 1)     ///< 0x0002  File is executable  (i.e. no unresolved externel references).
+#define EFI_IMAGE_FILE_LINE_NUMS_STRIPPED   (1 << 2)     ///< 0x0004  Line nunbers stripped from file.
+#define EFI_IMAGE_FILE_LOCAL_SYMS_STRIPPED  (1 << 3)     ///< 0x0008  Local symbols stripped from file.
+#define EFI_IMAGE_FILE_BYTES_REVERSED_LO    (1 << 7)     ///< 0x0080  Bytes of machine word are reversed.
+#define EFI_IMAGE_FILE_32BIT_MACHINE        (1 << 8)     ///< 0x0100  32 bit word machine.
+#define EFI_IMAGE_FILE_DEBUG_STRIPPED       (1 << 9)     ///< 0x0200  Debugging info stripped from file in .DBG file.
+#define EFI_IMAGE_FILE_SYSTEM               (1 << 12)    ///< 0x1000  System File.
+#define EFI_IMAGE_FILE_DLL                  (1 << 13)    ///< 0x2000  File is a DLL.
+#define EFI_IMAGE_FILE_BYTES_REVERSED_HI    (1 << 15)    ///< 0x8000  Bytes of machine word are reversed.
+
+///
+/// Header Data Directories.
+///
+typedef struct {
+  grub_uint32_t  VirtualAddress;
+  grub_uint32_t  Size;
+} EFI_IMAGE_DATA_DIRECTORY;
+
+//
+// Directory Entries
+//
+#define EFI_IMAGE_DIRECTORY_ENTRY_EXPORT      0
+#define EFI_IMAGE_DIRECTORY_ENTRY_IMPORT      1
+#define EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE    2
+#define EFI_IMAGE_DIRECTORY_ENTRY_EXCEPTION   3
+#define EFI_IMAGE_DIRECTORY_ENTRY_SECURITY    4
+#define EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC   5
+#define EFI_IMAGE_DIRECTORY_ENTRY_DEBUG       6
+#define EFI_IMAGE_DIRECTORY_ENTRY_COPYRIGHT   7
+#define EFI_IMAGE_DIRECTORY_ENTRY_GLOBALPTR   8
+#define EFI_IMAGE_DIRECTORY_ENTRY_TLS         9
+#define EFI_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
+
+#define EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES 16
+
+///
+/// @attention
+/// EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC means PE32 and 
+/// EFI_IMAGE_OPTIONAL_HEADER32 must be used. The data structures only vary
+/// after NT additional fields.
+///
+#define EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b
+          
+///
+/// Optional Header Standard Fields for PE32.
+///
+typedef struct {
+  ///
+  /// Standard fields.
+  ///
+  grub_uint16_t                    Magic;
+  grub_uint8_t                     MajorLinkerVersion;
+  grub_uint8_t                     MinorLinkerVersion;
+  grub_uint32_t                    SizeOfCode;
+  grub_uint32_t                    SizeOfInitializedData;
+  grub_uint32_t                    SizeOfUninitializedData;
+  grub_uint32_t                    AddressOfEntryPoint;
+  grub_uint32_t                    BaseOfCode;
+  grub_uint32_t                    BaseOfData;  ///< PE32 contains this additional field, which is absent in PE32+.
+  ///
+  /// Optional Header Windows-Specific Fields.
+  ///
+  grub_uint32_t                    ImageBase;
+  grub_uint32_t                    SectionAlignment;
+  grub_uint32_t                    FileAlignment;
+  grub_uint16_t                    MajorOperatingSystemVersion;
+  grub_uint16_t                    MinorOperatingSystemVersion;
+  grub_uint16_t                    MajorImageVersion;
+  grub_uint16_t                    MinorImageVersion;
+  grub_uint16_t                    MajorSubsystemVersion;
+  grub_uint16_t                    MinorSubsystemVersion;
+  grub_uint32_t                    Win32VersionValue;
+  grub_uint32_t                    SizeOfImage;
+  grub_uint32_t                    SizeOfHeaders;
+  grub_uint32_t                    CheckSum;
+  grub_uint16_t                    Subsystem;
+  grub_uint16_t                    DllCharacteristics;
+  grub_uint32_t                    SizeOfStackReserve;
+  grub_uint32_t                    SizeOfStackCommit;
+  grub_uint32_t                    SizeOfHeapReserve;
+  grub_uint32_t                    SizeOfHeapCommit;
+  grub_uint32_t                    LoaderFlags;
+  grub_uint32_t                    NumberOfRvaAndSizes;
+  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
+} EFI_IMAGE_OPTIONAL_HEADER32;
+
+///
+/// @attention
+/// EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC means PE32+ and 
+/// EFI_IMAGE_OPTIONAL_HEADER64 must be used. The data structures only vary
+/// after NT additional fields.
+///
+#define EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
+
+///
+/// Optional Header Standard Fields for PE32+.
+///
+typedef struct {
+  ///
+  /// Standard fields.
+  ///
+  grub_uint16_t                    Magic;
+  grub_uint8_t                     MajorLinkerVersion;
+  grub_uint8_t                     MinorLinkerVersion;
+  grub_uint32_t                    SizeOfCode;
+  grub_uint32_t                    SizeOfInitializedData;
+  grub_uint32_t                    SizeOfUninitializedData;
+  grub_uint32_t                    AddressOfEntryPoint;
+  grub_uint32_t                    BaseOfCode;
+  ///
+  /// Optional Header Windows-Specific Fields.
+  ///
+  grub_uint64_t                    ImageBase;
+  grub_uint32_t                    SectionAlignment;
+  grub_uint32_t                    FileAlignment;
+  grub_uint16_t                    MajorOperatingSystemVersion;
+  grub_uint16_t                    MinorOperatingSystemVersion;
+  grub_uint16_t                    MajorImageVersion;
+  grub_uint16_t                    MinorImageVersion;
+  grub_uint16_t                    MajorSubsystemVersion;
+  grub_uint16_t                    MinorSubsystemVersion;
+  grub_uint32_t                    Win32VersionValue;
+  grub_uint32_t                    SizeOfImage;
+  grub_uint32_t                    SizeOfHeaders;
+  grub_uint32_t                    CheckSum;
+  grub_uint16_t                    Subsystem;
+  grub_uint16_t                    DllCharacteristics;
+  grub_uint64_t                    SizeOfStackReserve;
+  grub_uint64_t                    SizeOfStackCommit;
+  grub_uint64_t                    SizeOfHeapReserve;
+  grub_uint64_t                    SizeOfHeapCommit;
+  grub_uint32_t                    LoaderFlags;
+  grub_uint32_t                    NumberOfRvaAndSizes;
+  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
+} EFI_IMAGE_OPTIONAL_HEADER64;
+
+
+///
+/// @attention
+/// EFI_IMAGE_NT_HEADERS32 is for use ONLY by tools.
+///
+typedef struct {
+  grub_uint32_t                      Signature;
+  EFI_IMAGE_FILE_HEADER       FileHeader;
+  EFI_IMAGE_OPTIONAL_HEADER32 OptionalHeader;
+} EFI_IMAGE_NT_HEADERS32;
+
+#define EFI_IMAGE_SIZEOF_NT_OPTIONAL32_HEADER sizeof (EFI_IMAGE_NT_HEADERS32)
+
+///
+/// @attention
+/// EFI_IMAGE_HEADERS64 is for use ONLY by tools.
+///
+typedef struct {
+  grub_uint32_t                      Signature;
+  EFI_IMAGE_FILE_HEADER       FileHeader;
+  EFI_IMAGE_OPTIONAL_HEADER64 OptionalHeader;
+} EFI_IMAGE_NT_HEADERS64;
+
+#define EFI_IMAGE_SIZEOF_NT_OPTIONAL64_HEADER sizeof (EFI_IMAGE_NT_HEADERS64)
+
+//
+// Other Windows Subsystem Values
+//
+#define EFI_IMAGE_SUBSYSTEM_UNKNOWN     0
+#define EFI_IMAGE_SUBSYSTEM_NATIVE      1
+#define EFI_IMAGE_SUBSYSTEM_WINDOWS_GUI 2
+#define EFI_IMAGE_SUBSYSTEM_WINDOWS_CUI 3
+#define EFI_IMAGE_SUBSYSTEM_OS2_CUI     5
+#define EFI_IMAGE_SUBSYSTEM_POSIX_CUI   7
+
+///
+/// Length of ShortName.
+///
+#define EFI_IMAGE_SIZEOF_SHORT_NAME 8
+
+///
+/// Section Table. This table immediately follows the optional header.
+///
+typedef struct {
+  grub_uint8_t Name[EFI_IMAGE_SIZEOF_SHORT_NAME];
+  union {
+    grub_uint32_t  PhysicalAddress;
+    grub_uint32_t  VirtualSize;
+  } Misc;
+  grub_uint32_t  VirtualAddress;
+  grub_uint32_t  SizeOfRawData;
+  grub_uint32_t  PointerToRawData;
+  grub_uint32_t  PointerToRelocations;
+  grub_uint32_t  PointerToLinenumbers;
+  grub_uint16_t  NumberOfRelocations;
+  grub_uint16_t  NumberOfLinenumbers;
+  grub_uint32_t  Characteristics;
+} EFI_IMAGE_SECTION_HEADER;
+
+///
+/// Size of EFI_IMAGE_SECTION_HEADER.
+///
+#define EFI_IMAGE_SIZEOF_SECTION_HEADER       40
+
+//
+// Section Flags Values
+//
+#define EFI_IMAGE_SCN_TYPE_NO_PAD                  0x00000008  ///< Reserved.
+#define EFI_IMAGE_SCN_CNT_CODE                     0x00000020
+#define EFI_IMAGE_SCN_CNT_INITIALIZED_DATA         0x00000040
+#define EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA       0x00000080
+
+#define EFI_IMAGE_SCN_LNK_OTHER                    0x00000100  ///< Reserved.
+#define EFI_IMAGE_SCN_LNK_INFO                     0x00000200  ///< Section contains comments or some other type of information.
+#define EFI_IMAGE_SCN_LNK_REMOVE                   0x00000800  ///< Section contents will not become part of image.
+#define EFI_IMAGE_SCN_LNK_COMDAT                   0x00001000
+
+#define EFI_IMAGE_SCN_ALIGN_1BYTES                 0x00100000
+#define EFI_IMAGE_SCN_ALIGN_2BYTES                 0x00200000
+#define EFI_IMAGE_SCN_ALIGN_4BYTES                 0x00300000
+#define EFI_IMAGE_SCN_ALIGN_8BYTES                 0x00400000
+#define EFI_IMAGE_SCN_ALIGN_16BYTES                0x00500000
+#define EFI_IMAGE_SCN_ALIGN_32BYTES                0x00600000
+#define EFI_IMAGE_SCN_ALIGN_64BYTES                0x00700000
+
+#define EFI_IMAGE_SCN_MEM_DISCARDABLE              0x02000000
+#define EFI_IMAGE_SCN_MEM_NOT_CACHED               0x04000000
+#define EFI_IMAGE_SCN_MEM_NOT_PAGED                0x08000000
+#define EFI_IMAGE_SCN_MEM_SHARED                   0x10000000
+#define EFI_IMAGE_SCN_MEM_EXECUTE                  0x20000000
+#define EFI_IMAGE_SCN_MEM_READ                     0x40000000
+#define EFI_IMAGE_SCN_MEM_WRITE                    0x80000000
+
+///
+/// Size of a Symbol Table Record.
+///
+#define EFI_IMAGE_SIZEOF_SYMBOL 18
+
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+#define EFI_IMAGE_SYM_UNDEFINED (grub_uint16_t) 0  ///< Symbol is undefined or is common.
+#define EFI_IMAGE_SYM_ABSOLUTE  (grub_uint16_t) -1 ///< Symbol is an absolute value.
+#define EFI_IMAGE_SYM_DEBUG     (grub_uint16_t) -2 ///< Symbol is a special debug item.
+
+//
+// Symbol Type (fundamental) values.
+//
+#define EFI_IMAGE_SYM_TYPE_NULL   0   ///< no type.
+#define EFI_IMAGE_SYM_TYPE_VOID   1   ///< no valid type.
+#define EFI_IMAGE_SYM_TYPE_CHAR   2   ///< type character.
+#define EFI_IMAGE_SYM_TYPE_SHORT  3   ///< type short integer.
+#define EFI_IMAGE_SYM_TYPE_INT    4
+#define EFI_IMAGE_SYM_TYPE_LONG   5
+#define EFI_IMAGE_SYM_TYPE_FLOAT  6
+#define EFI_IMAGE_SYM_TYPE_DOUBLE 7
+#define EFI_IMAGE_SYM_TYPE_STRUCT 8
+#define EFI_IMAGE_SYM_TYPE_UNION  9
+#define EFI_IMAGE_SYM_TYPE_ENUM   10  ///< enumeration.
+#define EFI_IMAGE_SYM_TYPE_MOE    11  ///< member of enumeration.
+#define EFI_IMAGE_SYM_TYPE_BYTE   12
+#define EFI_IMAGE_SYM_TYPE_WORD   13
+#define EFI_IMAGE_SYM_TYPE_UINT   14
+#define EFI_IMAGE_SYM_TYPE_DWORD  15
+
+//
+// Symbol Type (derived) values.
+//
+#define EFI_IMAGE_SYM_DTYPE_NULL      0 ///< no derived type.
+#define EFI_IMAGE_SYM_DTYPE_POINTER   1
+#define EFI_IMAGE_SYM_DTYPE_FUNCTION  2
+#define EFI_IMAGE_SYM_DTYPE_ARRAY     3
+
+//
+// Storage classes.
+//
+#define EFI_IMAGE_SYM_CLASS_END_OF_FUNCTION   ((grub_uint8_t) -1)
+#define EFI_IMAGE_SYM_CLASS_NULL              0
+#define EFI_IMAGE_SYM_CLASS_AUTOMATIC         1
+#define EFI_IMAGE_SYM_CLASS_EXTERNAL          2
+#define EFI_IMAGE_SYM_CLASS_STATIC            3
+#define EFI_IMAGE_SYM_CLASS_REGISTER          4
+#define EFI_IMAGE_SYM_CLASS_EXTERNAL_DEF      5
+#define EFI_IMAGE_SYM_CLASS_LABEL             6
+#define EFI_IMAGE_SYM_CLASS_UNDEFINED_LABEL   7
+#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_STRUCT  8
+#define EFI_IMAGE_SYM_CLASS_ARGUMENT          9
+#define EFI_IMAGE_SYM_CLASS_STRUCT_TAG        10
+#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_UNION   11
+#define EFI_IMAGE_SYM_CLASS_UNION_TAG         12
+#define EFI_IMAGE_SYM_CLASS_TYPE_DEFINITION   13
+#define EFI_IMAGE_SYM_CLASS_UNDEFINED_STATIC  14
+#define EFI_IMAGE_SYM_CLASS_ENUM_TAG          15
+#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_ENUM    16
+#define EFI_IMAGE_SYM_CLASS_REGISTER_PARAM    17
+#define EFI_IMAGE_SYM_CLASS_BIT_FIELD         18
+#define EFI_IMAGE_SYM_CLASS_BLOCK             100
+#define EFI_IMAGE_SYM_CLASS_FUNCTION          101
+#define EFI_IMAGE_SYM_CLASS_END_OF_STRUCT     102
+#define EFI_IMAGE_SYM_CLASS_FILE              103
+#define EFI_IMAGE_SYM_CLASS_SECTION           104
+#define EFI_IMAGE_SYM_CLASS_WEAK_EXTERNAL     105
+
+//
+// type packing constants
+//
+#define EFI_IMAGE_N_BTMASK  017
+#define EFI_IMAGE_N_TMASK   060
+#define EFI_IMAGE_N_TMASK1  0300
+#define EFI_IMAGE_N_TMASK2  0360
+#define EFI_IMAGE_N_BTSHFT  4
+#define EFI_IMAGE_N_TSHIFT  2
+
+//
+// Communal selection types.
+//
+#define EFI_IMAGE_COMDAT_SELECT_NODUPLICATES    1
+#define EFI_IMAGE_COMDAT_SELECT_ANY             2
+#define EFI_IMAGE_COMDAT_SELECT_SAME_SIZE       3
+#define EFI_IMAGE_COMDAT_SELECT_EXACT_MATCH     4
+#define EFI_IMAGE_COMDAT_SELECT_ASSOCIATIVE     5
+                                       
+//
+// the following values only be referred in PeCoff, not defined in PECOFF.
+//
+#define EFI_IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
+#define EFI_IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
+#define EFI_IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3
+
+///
+/// Relocation format.
+///
+typedef struct {
+  grub_uint32_t  VirtualAddress;
+  grub_uint32_t  SymbolTableIndex;
+  grub_uint16_t  Type;
+} EFI_IMAGE_RELOCATION;
+
+///
+/// Size of EFI_IMAGE_RELOCATION
+///
+#define EFI_IMAGE_SIZEOF_RELOCATION 10
+
+//
+// I386 relocation types.
+//
+#define EFI_IMAGE_REL_I386_ABSOLUTE 0x0000  ///< Reference is absolute, no relocation is necessary.
+#define EFI_IMAGE_REL_I386_DIR16    0x0001  ///< Direct 16-bit reference to the symbols virtual address.
+#define EFI_IMAGE_REL_I386_REL16    0x0002  ///< PC-relative 16-bit reference to the symbols virtual address.
+#define EFI_IMAGE_REL_I386_DIR32    0x0006  ///< Direct 32-bit reference to the symbols virtual address.
+#define EFI_IMAGE_REL_I386_DIR32NB  0x0007  ///< Direct 32-bit reference to the symbols virtual address, base not included.
+#define EFI_IMAGE_REL_I386_SEG12    0x0009  ///< Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address.
+#define EFI_IMAGE_REL_I386_SECTION  0x000A
+#define EFI_IMAGE_REL_I386_SECREL   0x000B
+#define EFI_IMAGE_REL_I386_REL32    0x0014  ///< PC-relative 32-bit reference to the symbols virtual address.
+
+// 
+// x64 processor relocation types.
+// 
+#define IMAGE_REL_AMD64_ABSOLUTE  0x0000
+#define IMAGE_REL_AMD64_ADDR64    0x0001
+#define IMAGE_REL_AMD64_ADDR32    0x0002
+#define IMAGE_REL_AMD64_ADDR32NB  0x0003
+#define IMAGE_REL_AMD64_REL32     0x0004
+#define IMAGE_REL_AMD64_REL32_1   0x0005
+#define IMAGE_REL_AMD64_REL32_2   0x0006
+#define IMAGE_REL_AMD64_REL32_3   0x0007
+#define IMAGE_REL_AMD64_REL32_4   0x0008
+#define IMAGE_REL_AMD64_REL32_5   0x0009
+#define IMAGE_REL_AMD64_SECTION   0x000A
+#define IMAGE_REL_AMD64_SECREL    0x000B
+#define IMAGE_REL_AMD64_SECREL7   0x000C
+#define IMAGE_REL_AMD64_TOKEN     0x000D
+#define IMAGE_REL_AMD64_SREL32    0x000E
+#define IMAGE_REL_AMD64_PAIR      0x000F
+#define IMAGE_REL_AMD64_SSPAN32   0x0010
+
+///
+/// Based relocation format.
+///
+typedef struct {
+  grub_uint32_t  VirtualAddress;
+  grub_uint32_t  SizeOfBlock;
+} EFI_IMAGE_BASE_RELOCATION;
+
+///
+/// Size of EFI_IMAGE_BASE_RELOCATION.
+///
+#define EFI_IMAGE_SIZEOF_BASE_RELOCATION  8
+
+//
+// Based relocation types.
+//
+#define EFI_IMAGE_REL_BASED_ABSOLUTE        0
+#define EFI_IMAGE_REL_BASED_HIGH            1
+#define EFI_IMAGE_REL_BASED_LOW             2
+#define EFI_IMAGE_REL_BASED_HIGHLOW         3
+#define EFI_IMAGE_REL_BASED_HIGHADJ         4
+#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR    5
+#define EFI_IMAGE_REL_BASED_ARM_MOV32A      5
+#define EFI_IMAGE_REL_BASED_ARM_MOV32T      7
+#define EFI_IMAGE_REL_BASED_IA64_IMM64      9
+#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR16  9
+#define EFI_IMAGE_REL_BASED_DIR64           10
+
+///
+/// Line number format.
+///
+typedef struct {
+  union {
+    grub_uint32_t  SymbolTableIndex; ///< Symbol table index of function name if Linenumber is 0.
+    grub_uint32_t  VirtualAddress;   ///< Virtual address of line number.
+  } Type;
+  grub_uint16_t  Linenumber;         ///< Line number.
+} EFI_IMAGE_LINENUMBER;
+
+///
+/// Size of EFI_IMAGE_LINENUMBER.
+///
+#define EFI_IMAGE_SIZEOF_LINENUMBER 6
+
+//
+// Archive format.
+//
+#define EFI_IMAGE_ARCHIVE_START_SIZE        8
+#define EFI_IMAGE_ARCHIVE_START             "!<arch>\n"
+#define EFI_IMAGE_ARCHIVE_END               "`\n"
+#define EFI_IMAGE_ARCHIVE_PAD               "\n"
+#define EFI_IMAGE_ARCHIVE_LINKER_MEMBER     "/               "
+#define EFI_IMAGE_ARCHIVE_LONGNAMES_MEMBER  "//              "
+
+///
+/// Archive Member Headers
+///
+typedef struct {
+  grub_uint8_t Name[16];     ///< File member name - `/' terminated.
+  grub_uint8_t Date[12];     ///< File member date - decimal.
+  grub_uint8_t UserID[6];    ///< File member user id - decimal.
+  grub_uint8_t GroupID[6];   ///< File member group id - decimal.
+  grub_uint8_t Mode[8];      ///< File member mode - octal.
+  grub_uint8_t Size[10];     ///< File member size - decimal.
+  grub_uint8_t EndHeader[2]; ///< String to end header. (0x60 0x0A).
+} EFI_IMAGE_ARCHIVE_MEMBER_HEADER;
+
+///
+/// Size of EFI_IMAGE_ARCHIVE_MEMBER_HEADER.
+///
+#define EFI_IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60
+
+
+//
+// DLL Support
+//
+
+///
+/// Export Directory Table.
+///
+typedef struct {
+  grub_uint32_t  Characteristics;
+  grub_uint32_t  TimeDateStamp;
+  grub_uint16_t  MajorVersion;
+  grub_uint16_t  MinorVersion;
+  grub_uint32_t  Name;
+  grub_uint32_t  Base;
+  grub_uint32_t  NumberOfFunctions;
+  grub_uint32_t  NumberOfNames;
+  grub_uint32_t  AddressOfFunctions;
+  grub_uint32_t  AddressOfNames;
+  grub_uint32_t  AddressOfNameOrdinals;
+} EFI_IMAGE_EXPORT_DIRECTORY;
+
+///
+/// Hint/Name Table.
+///
+typedef struct {
+  grub_uint16_t  Hint;
+  grub_uint8_t   Name[1];
+} EFI_IMAGE_IMPORT_BY_NAME;
+
+///
+/// Import Address Table RVA (Thunk Table).
+///
+typedef struct {
+  union {
+    grub_uint32_t                    Function;
+    grub_uint32_t                    Ordinal;
+    EFI_IMAGE_IMPORT_BY_NAME  *AddressOfData;
+  } u1;
+} EFI_IMAGE_THUNK_DATA;
+
+#define EFI_IMAGE_ORDINAL_FLAG              BIT31    ///< Flag for PE32.
+#define EFI_IMAGE_SNAP_BY_ORDINAL(Ordinal)  ((Ordinal & EFI_IMAGE_ORDINAL_FLAG) != 0)
+#define EFI_IMAGE_ORDINAL(Ordinal)          (Ordinal & 0xffff)
+
+///
+/// Import Directory Table
+///
+typedef struct {
+  grub_uint32_t                Characteristics;
+  grub_uint32_t                TimeDateStamp;
+  grub_uint32_t                ForwarderChain;
+  grub_uint32_t                Name;
+  EFI_IMAGE_THUNK_DATA  *FirstThunk;
+} EFI_IMAGE_IMPORT_DESCRIPTOR;
+
+
+///
+/// Debug Directory Format.
+///
+typedef struct {
+  grub_uint32_t  Characteristics;
+  grub_uint32_t  TimeDateStamp;
+  grub_uint16_t  MajorVersion;
+  grub_uint16_t  MinorVersion;
+  grub_uint32_t  Type;
+  grub_uint32_t  SizeOfData;
+  grub_uint32_t  RVA;           ///< The address of the debug data when loaded, relative to the image base.
+  grub_uint32_t  FileOffset;    ///< The file pointer to the debug data.
+} EFI_IMAGE_DEBUG_DIRECTORY_ENTRY;
+
+#define EFI_IMAGE_DEBUG_TYPE_CODEVIEW 2     ///< The Visual C++ debug information.
+
+///
+/// Debug Data Structure defined in Microsoft C++.
+///
+#define CODEVIEW_SIGNATURE_NB10  SIGNATURE_32('N', 'B', '1', '0')
+typedef struct {
+  grub_uint32_t  Signature;                        ///< "NB10"
+  grub_uint32_t  Unknown;
+  grub_uint32_t  Unknown2;
+  grub_uint32_t  Unknown3;
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;
+
+///
+/// Debug Data Structure defined in Microsoft C++.
+///
+#define CODEVIEW_SIGNATURE_RSDS  SIGNATURE_32('R', 'S', 'D', 'S')
+typedef struct {
+  grub_uint32_t  Signature;                        ///< "RSDS".
+  grub_uint32_t  Unknown;
+  grub_uint32_t  Unknown2;
+  grub_uint32_t  Unknown3;
+  grub_uint32_t  Unknown4;
+  grub_uint32_t  Unknown5;
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;
+
+
+///
+/// Debug Data Structure defined by Apple Mach-O to Coff utility.
+///
+#define CODEVIEW_SIGNATURE_MTOC  SIGNATURE_32('M', 'T', 'O', 'C')
+typedef struct {
+  grub_uint32_t    Signature;                       ///< "MTOC".
+  grub_efi_guid_t  MachOUuid;
+  //
+  //  Filename of .DLL (Mach-O with debug info) goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY;
+
+///
+/// Resource format.
+///
+typedef struct {
+  grub_uint32_t  Characteristics;
+  grub_uint32_t  TimeDateStamp;
+  grub_uint16_t  MajorVersion;
+  grub_uint16_t  MinorVersion;
+  grub_uint16_t  NumberOfNamedEntries;
+  grub_uint16_t  NumberOfIdEntries;
+  //
+  // Array of EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY entries goes here.
+  //
+} EFI_IMAGE_RESOURCE_DIRECTORY;
+
+///
+/// Resource directory entry format.
+///
+typedef struct {
+  union {
+    struct {
+      grub_uint32_t  NameOffset:31;
+      grub_uint32_t  NameIsString:1;
+    } s;
+    grub_uint32_t  Id;
+  } u1;
+  union {
+    grub_uint32_t  OffsetToData;
+    struct {
+      grub_uint32_t  OffsetToDirectory:31;
+      grub_uint32_t  DataIsDirectory:1;
+    } s;
+  } u2;
+} EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY;
+
+///
+/// Resource directory entry for string.
+///
+typedef struct {
+  grub_uint16_t  Length;
+  grub_efi_char16_t  String[1];
+} EFI_IMAGE_RESOURCE_DIRECTORY_STRING;
+
+///
+/// Resource directory entry for data array.
+///
+typedef struct {
+  grub_uint32_t  OffsetToData;
+  grub_uint32_t  Size;
+  grub_uint32_t  CodePage;
+  grub_uint32_t  Reserved;
+} EFI_IMAGE_RESOURCE_DATA_ENTRY;
+
+///
+/// Header format for TE images, defined in the PI Specification, 1.0.
+///
+typedef struct {
+  grub_uint16_t                    Signature;            ///< The signature for TE format = "VZ".
+  grub_uint16_t                    Machine;              ///< From the original file header.
+  grub_uint8_t                     NumberOfSections;     ///< From the original file header.
+  grub_uint8_t                     Subsystem;            ///< From original optional header.
+  grub_uint16_t                    StrippedSize;         ///< Number of bytes we removed from the header.
+  grub_uint32_t                    AddressOfEntryPoint;  ///< Offset to entry point -- from original optional header.
+  grub_uint32_t                    BaseOfCode;           ///< From original image -- required for ITP debug.
+  grub_uint64_t                    ImageBase;            ///< From original file header.
+  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[2];     ///< Only base relocation and debug directory.
+} EFI_TE_IMAGE_HEADER;
+
+
+#define EFI_TE_IMAGE_HEADER_SIGNATURE  SIGNATURE_16('V', 'Z')
+
+//
+// Data directory indexes in our TE image header
+//
+#define EFI_TE_IMAGE_DIRECTORY_ENTRY_BASERELOC  0
+#define EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG      1
+
+
+///
+/// Union of PE32, PE32+, and TE headers.
+///
+typedef union {
+  EFI_IMAGE_NT_HEADERS32   Pe32;
+  EFI_IMAGE_NT_HEADERS64   Pe32Plus;
+  EFI_TE_IMAGE_HEADER      Te;
+} EFI_IMAGE_OPTIONAL_HEADER_UNION;
+
+typedef union {
+  EFI_IMAGE_NT_HEADERS32            *Pe32;
+  EFI_IMAGE_NT_HEADERS64            *Pe32Plus;
+  EFI_TE_IMAGE_HEADER               *Te;
+  EFI_IMAGE_OPTIONAL_HEADER_UNION   *Union;
+} EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION;
+
+#endif /* SHIM_PEIMAGE_H */
-- 
2.33.1

