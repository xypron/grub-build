From 5bf070ddb6cbcc5af3725908a2e092fd02352f4c Mon Sep 17 00:00:00 2001
From: Heinrich Schuchardt <heinrich.schuchardt@canonical.com>
Date: Fri, 18 Mar 2022 15:21:33 +0100
Subject: [PATCH 1/1] efivar: check that efivarfs is writeable

Some UEFI implementations (notably U-Boot) don't implement the
SetVariable() runtime service. On these systems the GRUB installation
must be completed manually. Write a warning in this case but avoid
throwing an error.

Signed-off-by: Heinrich Schuchardt <heinrich.schuchardt@canonical.com>
---
 grub-core/osdep/unix/efivar.c | 81 +++++++++++++++++++++++++++++++++++
 1 file changed, 81 insertions(+)

diff --git a/grub-core/osdep/unix/efivar.c b/grub-core/osdep/unix/efivar.c
index d34df0f70..8a7ee0c94 100644
--- a/grub-core/osdep/unix/efivar.c
+++ b/grub-core/osdep/unix/efivar.c
@@ -511,6 +511,79 @@ devices_equal (const_efidp a, const_efidp b)
   return false;
 }
 
+/**
+ * efivar_is_rw - detect if the efivar file system exists and is writeable
+ *
+ * Return:	true if efivarfs is writeable
+ */
+static bool
+efivar_is_rw (void)
+{
+  const char filename[] = "/proc/self/mounts";
+  int fd;
+  grub_uint64_t size;
+  char *data = NULL, *start, *end, *pos;
+  bool ret = false;
+
+  fd = grub_util_fd_open (filename, GRUB_UTIL_FD_O_RDONLY);
+  if (fd == -1)
+    {
+      grub_util_warn (_("cannot open `%s': %s"), filename, strerror (errno));
+      return 0;
+    }
+
+  /*
+   * /proc/self/mounts does not provide a filesize. So read it into an initial
+   * buffer. If the last byte of the buffer is overwritten, retry with double
+   * the buffer size.
+   */
+  size = 4096;
+  for (;;) {
+    ssize_t s;
+
+    fd = grub_util_fd_open (filename, GRUB_UTIL_FD_O_RDONLY);
+    if (fd == -1)
+      {
+        grub_util_warn (_("cannot open `%s': %s"), filename, strerror (errno));
+        return 0;
+      }
+
+    grub_util_info ("size %ld", size);
+    data = xmalloc (size);
+    grub_memset (data, 0, size);
+    if (!data)
+      {
+        grub_util_warn ("%s", _("out of memory"));
+        goto out;
+      }
+    s = read(fd, data, size);
+    if (s < 0)
+      {
+        grub_util_warn (_("cannot read `%s': %s"), filename, strerror (errno));
+        goto out;
+      }
+    grub_util_fd_close (fd);
+    if (!data[size - 1])
+        break;
+    free(data);
+    size *= 2;
+  }
+
+  start = grub_strstr (data, "efivarfs ");
+  if (!start)
+    goto out;
+  end = grub_strstr (start, "\n");
+  if (!end)
+    goto out;
+  pos = grub_strstr (start, " rw,");
+  if (pos && pos < end)
+    ret = true;
+
+out:
+  grub_free (data);
+  return ret;
+}
+
 int
 grub_install_efivar_register_efi (grub_device_t efidir_grub_dev,
 				  const char *efidir, const char *efifile_path,
@@ -528,6 +601,14 @@ grub_install_efivar_register_efi (grub_device_t efidir_grub_dev,
   int rc;
   bool is_boot_efi;
 
+  /* Check if EFI variable can be written */
+  if (!efivar_is_rw ())
+    {
+      grub_util_warn ("EFI variables cannot be set on this system");
+      grub_util_warn ("You will have to complete the GRUB setup manually");
+      return 0;
+    }
+
   is_boot_efi = strstr (efidir, "/boot/efi") != NULL;
   efidir_disk = grub_util_biosdisk_get_osdev (efidir_grub_dev->disk);
   efidir_part = efidir_grub_dev->disk->partition ? efidir_grub_dev->disk->partition->number + 1 : 1;
-- 
2.34.1

